# IPv6, 유닉스 도메인 소켓, 네트워크 인터페이스

## 내부 포트를 외부 호스트로 포워딩하기
프록시 서버 사용자에게 특정 웹사이트 접근을 허가하면서 특정 사이트 접근을 막는 등, 특정 내부 포트의 모든 통신 내용을 특정 외부 호스트에 재지향하는 포트 포워징 스크립트를 작성해야 할 경우도 있다.  

- 3_1_port_forwarding.py --local-port=8800 --local-host=localhost --remote-host=www.google.com

8800번 포트로 수신한 모든 데이터를 구글로 재지향하는 포트 포워딩 스크립트.

파일 실행후 http://localhost:8800 으로 접속하면 구글로 이동하고, 내부 포트를 외부 호스트로 포워딩한다.


`asyncore.dispather` 클래스는 소켓 객체를 감싸는 래퍼 클래스.  
접속이 성공적으로 이루어졌을 때, 클라이언트가 서버 소켓에 연결했을 떄 등의 이벤트를 처리한다.

예제의 PortForwarding 클래스는 내부 소켓으로부터 들어오는 클라이언트의 요청을 받아들여 이를 Sender 클래스의 객체에 전달하고 이 객체는 Receiver 클래스의 객체를 이용해 외부 호스트의 저정된 포트로 양방향 통신을 개시한다.
(인터넷이 안되어 추후 테스트 예정 ㅠ)

## 네트워크상의 호스트에 ICMP를 이용해 ping 요청하기

- 3_2_ping_remote_host.py --target-host=www.google.com

 - target_host : ping을 전송할 대상 호스트 주소
 - count : ping 횟수 지정 변수
 - timeout : ping 전송을 완료하지 못할 경우 종료 시간 지정

- send_ping()은 대상 호스트의 DNS 호스트 이름을 얻고 struct 모듈을 이용해 ICMP_ECHO_REQUEST 패킷을 생성한다.
- 소스 문자열(데이터)을 받아들여 이에 대응하는 체크섬을 생는 do_checksum()을 이용해 데이터의 무결성을 확인
- 데이터를 수신하는 쪽은 receive_pong()을 이용해 타임아웃이나 대기한다.
- 이 함수는 ICMP 응답 헤더를 수신해 패킷 아이디를 비교한 후 ping 요청과 응답에 걸린 지연 시간을 계산한다.

## 외부 네트워크 서비스 사용 대기

네트워크 서비스가 다시 복구되기를 기다리는 동안 해당 서버가 연결 가능한지 점검하는 스크립트.  

예제에서는 localhost에 있는 웹 서버가 실행 중인지 점검한다.

- 3_3_wait_for_remote_service.py

 - NetServiceChecker 클래스의 객체를 생성한후 check() 메소드를 호출
 - 이 메소드는 기다려야 하는 시간을 계산한 후 소켓의 settimeout()을 호출해 반복문 내에서 각 순회마다 다음 타임아웃 시간을 지정
 - 소켓의 connect()를 이용해 소켓의 타임아웃이 발생하기 전까지 원하는 네트워크 서비스가 이용 가능한지 점검
 - 이 메소드는 소켓 타임아웃 에러가 발생하면 현재 소켓의 타임아웃 시간과 사용자가 지정한 타임아웃 시간을 비교

## 컴퓨터에 있는 모든 네트워크 인터페이스 찾기
리눅스 환경에서만 해당됨. 윈도우에서는 아래 이슈가 발생함.
[Add support for Windows (ImportError: No module named fcntl)](https://github.com/cs01/gdbgui/issues/18)

 - list_interfaces()는 소켓 객체를 생성한 후 이 객체를 이용해 네트워크 인터페잇 정보를 찾음
 - fnctl 모듈에 있는 ioctl()를 호출하여 처리
 - fnctl 모듈은 fnctl()과 같은 전통적인 유닉스 함수를 사용함
 - 이 함수는 소켓의 파일 디스크립터를 이용해 I/O 작업을 수행
 - 디스크립터는 소켓 객체상에서 fileno() 를 호출해서 얻음

 - ioctl()의 매개변수에는 C 소켓 라이브러리에 정의된 SIOCFIADDR 상수와 struct 모듈의 pack()을 호출해 생성한 데이터 구조가 있다.
 - 이 데이터 구조가 가리키는 메모리의 내용은 ioctl() 호출의 결과로 수정된다.

## 컴퓨터의 특정 네트워크 인터페이스 IP 주소 얻기
(리눅스 환경에서만 동작한다.)

- 3_5_get_interface_ip_address.py --ifname=eth0
명령행 인자로 IP 주소를 얻으려는 네트워크 인터페이스 이름을 받는다.  
`socket.inet_ntoa()`는 이진 데이터를 사람이 읽을 수 있는 IP 문자열로 변환해준다.

## 컴퓨터상의 네트워크 인터페이스 사용 가능 여부 알아내기
실제로 사용 중인 인터페이스를 통해 통신 할 수 있는지 알아내기.  
리눅스에서만 동작한다.  

명령행 인자를 `get_interface_status()`으로 전달하여 UDP 소켓 객체를 이용해 그 인터페이스 IP 주소를 찾는다.

- 3_6_find_network_interface_status.py --ifname=eth0

## 내부 네트워크상에서 비활성화된 컴퓨터 탐지
네트워크를 스캐닝하는 프로그램.  
Scapy는 네트워크 분석 라이브러리로, ICMP 스캐닝을 실행한다.  
이 작업을 주기적으로 실행하야 하므로 스케쥴링하는 sched 모듈이 필요하다.  

- 3_7_detect_inactive_machines.py --scan-hosts=10.0.2.2-4

 - 명령행 인자를 통해 네트워크 호스트의 목록을 넘겨받는다.
 - 1초 후 detect_inactive_hosts()를 실행해 스케줄을 생성한다.
 - 이 함수는 scan_hosts를 매개변수로 받고 Scapy의 sr() 함수를 호출한다.
 - sr()은 schedule.enter()를 다시 호출해 10초마다 재귀하여 주기적으로 스캐닝을 한다.
Scapy의 sr()은 IP 주소 목록, 하위 프로토콜, 그 외 스캐닝 관련 정보를 매개변수로 받는다.  
sr()은 응답하는 호스트와 응답하지 않는 호스트 정보를 튜플로 반환한다.

## 연결된 소켓을 이용한 기본적인 IPC 실행
두 스크립트로 프로세스 간에 정보를 교환해야 할 경우가 있다. 유닉스/리눅스의 연결된 소켓(socketpair)이라는 개념을 이용한다.  

리눅스에서만 동작한다.  

- 3_8_using_socketpaires.py

`socket.socketpair()`는 서로 연결된 두 소켓 객체를 반환.  
예제에서는 하나는 부모 프로세스, 다른 하나는 자식 프로세스에서 사용한다.  
`os.fork()`로 다른 프로세스를 생성하는데, 부모의 프로세스 아이디를 반환한다.  
각 프로세스에서는 먼저 다른 프로세스의 소켓을 종료하고 각 프로세스의 소켓상에 sendall()을 호출해 메시지를 교환한다.

## 유닉스 도메인 소켓을 이용한 IPC 실행

## 파이썬의 IPv6 소켓 지원 여부 확인

## IPv6 주소로부터 IPv6 프리픽스 추출

## IPv6 에코 클라이언트/서버 작성
